
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace DotNet.Plugin.Business
{
    public class PluginLoader
    {
        public static List<IPlugin> Plugins { get; set; }

        public void LoadPlugins()
        {
            Plugins = new List<IPlugin>();

            if(Directory.Exists(Constants.FolderName))
            {
                string[] files = Directory.GetFiles(Constants.FolderName);
                foreach (string file in files)
                {
                    if (file.EndsWith(".dll"))
                    {
                        Assembly.LoadFile(Path.GetFullPath(file));
                    }
                }
            }

            Type interfaceType = typeof(IPlugin);

            Type[] types = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(a => a.GetTypes())
                .Where(p => interfaceType.IsAssignableFrom(p) && p.IsClass && !p.IsAbstract)
                .ToArray();

            foreach(Type type in types)
            {
                Plugins.Add((IPlugin)Activator.CreateInstance(type));
            }

			SortPlugins();
        }

		private void SortPlugins()
		{
			//Idea from: https://stackoverflow.com/questions/7099741/c-sharp-list-sort-by-two-columns
			Plugins = Plugins.OrderBy(a=>a.Category).ThenBy(a=>a.Name).ToList();
		}
    }
}
namespace DotNet.Plugin.Business
{
    public interface IPlugin
    {
        string Name { get; }
		string Category { get; }
        string Explanation { get; }
        void Go(string parameters);
    }
}
﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.Internal;
using McMaster.NETCore.Plugins.Loader;

namespace McMaster.NETCore.Plugins
{
    /// <summary>
    /// This loader attempts to load binaries for execution (both managed assemblies and native libraries)
    /// in the same way that .NET Core would if they were originally part of the .NET Core application.
    /// <para>
    /// This loader reads configuration files produced by .NET Core (.deps.json and runtimeconfig.json)
    /// as well as a custom file (*.config files). These files describe a list of .dlls and a set of dependencies.
    /// The loader searches the plugin path, as well as any additionally specified paths, for binaries
    /// which satisfy the plugin's requirements.
    /// </para>
    /// </summary>
    public class PluginLoader : IDisposable
    {
#if FEATURE_UNLOAD
        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="isUnloadable">Enable unloading the plugin from memory.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, bool isUnloadable, Type[] sharedTypes)
            => CreateFromAssemblyFile(assemblyFile, isUnloadable, sharedTypes, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="isUnloadable">Enable unloading the plugin from memory.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, bool isUnloadable, Type[] sharedTypes, Action<PluginConfig> configure)
        {
            return CreateFromAssemblyFile(assemblyFile,
                    sharedTypes,
                    config =>
                    {
                        config.IsUnloadable = isUnloadable;
                        configure(config);
                    });
        }
#endif

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Type[] sharedTypes)
            => CreateFromAssemblyFile(assemblyFile, sharedTypes, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="sharedTypes">
        /// <para>
        /// A list of types which should be shared between the host and the plugin.
        /// </para>
        /// <para>
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md">
        /// https://github.com/natemcmaster/DotNetCorePlugins/blob/main/docs/what-are-shared-types.md
        /// </seealso>
        /// </para>
        /// </param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Type[] sharedTypes, Action<PluginConfig> configure)
        {
            return CreateFromAssemblyFile(assemblyFile,
                    config =>
                    {
                        if (sharedTypes != null)
                        {
                            var uniqueAssemblies = new HashSet<Assembly>();
                            foreach (var type in sharedTypes)
                            {
                                uniqueAssemblies.Add(type.Assembly);
                            }

                            foreach (var assembly in uniqueAssemblies)
                            {
                                config.SharedAssemblies.Add(assembly.GetName());
                            }
                        }
                        configure(config);
                    });
        }

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile)
            => CreateFromAssemblyFile(assemblyFile, _ => { });

        /// <summary>
        /// Create a plugin loader for an assembly file.
        /// </summary>
        /// <param name="assemblyFile">The file path to the main assembly for the plugin.</param>
        /// <param name="configure">A function which can be used to configure advanced options for the plugin loader.</param>
        /// <returns>A loader.</returns>
        public static PluginLoader CreateFromAssemblyFile(string assemblyFile, Action<PluginConfig> configure)
        {
            if (configure == null)
            {
                throw new ArgumentNullException(nameof(configure));
            }

            var config = new PluginConfig(assemblyFile);
            configure(config);
            return new PluginLoader(config);
        }

        private readonly PluginConfig _config;
        private ManagedLoadContext _context;
        private readonly AssemblyLoadContextBuilder _contextBuilder;
        private volatile bool _disposed;

#if FEATURE_UNLOAD
        private FileSystemWatcher? _fileWatcher;
        private Debouncer? _debouncer;
#endif

        /// <summary>
        /// Initialize an instance of <see cref="PluginLoader" />
        /// </summary>
        /// <param name="config">The configuration for the plugin.</param>
        public PluginLoader(PluginConfig config)
        {
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _contextBuilder = CreateLoadContextBuilder(config);
            _context = (ManagedLoadContext)_contextBuilder.Build();
#if FEATURE_UNLOAD
            if (config.EnableHotReload)
            {
                StartFileWatcher();
            }
#endif
        }

        /// <summary>
        /// True when this plugin is capable of being unloaded.
        /// </summary>
        public bool IsUnloadable
        {
            get
            {
#if FEATURE_UNLOAD
                return _context.IsCollectible;
#else
                return false;
#endif
            }
        }

#if FEATURE_UNLOAD

        /// <summary>
        /// This event is raised when the plugin has been reloaded.
        /// If <see cref="PluginConfig.EnableHotReload" /> was set to <c>true</c>,
        /// the plugin will be reloaded when files on disk are changed.
        /// </summary>
        public event PluginReloadedEventHandler? Reloaded;

        /// <summary>
        /// The unloads and reloads the plugin assemblies.
        /// This method throws if <see cref="IsUnloadable" /> is <c>false</c>.
        /// </summary>
        public void Reload()
        {
            EnsureNotDisposed();

            if (!IsUnloadable)
            {
                throw new InvalidOperationException("Reload cannot be used because IsUnloadable is false");
            }

            _context.Unload();
            _context = (ManagedLoadContext)_contextBuilder.Build();
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Reloaded?.Invoke(this, new PluginReloadedEventArgs(this));
        }

        private void StartFileWatcher()
        {
            /*
            This is a very simple implementation.
            Some improvements that could be made in the future:

                * Watch all directories which contain assemblies that could be loaded
                * Support a polling file watcher.
                * Handle delete/recreate better.

            If you're interested in making improvements, feel free to send a pull request.
            */

            _debouncer = new Debouncer(_config.ReloadDelay);

            _fileWatcher = new FileSystemWatcher
            {
                Path = Path.GetDirectoryName(_config.MainAssemblyPath)
            };
            _fileWatcher.Changed += OnFileChanged;
            _fileWatcher.Filter = "*.dll";
            _fileWatcher.NotifyFilter = NotifyFilters.LastWrite;
            _fileWatcher.EnableRaisingEvents = true;
        }

        private void OnFileChanged(object source, FileSystemEventArgs e)
        {
            if (!_disposed)
            {
                _debouncer?.Execute(Reload);
            }
        }
#endif

        internal AssemblyLoadContext LoadContext => _context;

        /// <summary>
        /// Load the main assembly for the plugin.
        /// </summary>
        public Assembly LoadDefaultAssembly()
        {
            EnsureNotDisposed();
            return _context.LoadAssemblyFromFilePath(_config.MainAssemblyPath);
        }

        /// <summary>
        /// Load an assembly by name.
        /// </summary>
        /// <param name="assemblyName">The assembly name.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssembly(AssemblyName assemblyName)
        {
            EnsureNotDisposed();
            return _context.LoadFromAssemblyName(assemblyName);
        }

        /// <summary>
        /// Load an assembly from path.
        /// </summary>
        /// <param name="assemblyPath">The assembly path.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssemblyFromPath(string assemblyPath)
            => _context.LoadAssemblyFromFilePath(assemblyPath);

        /// <summary>
        /// Load an assembly by name.
        /// </summary>
        /// <param name="assemblyName">The assembly name.</param>
        /// <returns>The assembly.</returns>
        public Assembly LoadAssembly(string assemblyName)
        {
            EnsureNotDisposed();
            return LoadAssembly(new AssemblyName(assemblyName));
        }

#if !NETCOREAPP2_1
        /// <summary>
        /// Sets the scope used by some System.Reflection APIs which might trigger assembly loading.
        /// <para>
        /// See https://github.com/dotnet/coreclr/blob/v3.0.0/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md for more details.
        /// </para>
        /// </summary>
        /// <returns></returns>
        public AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection()
            => _context.EnterContextualReflection();
#endif

        /// <summary>
        /// Disposes the plugin loader. This only does something if <see cref="IsUnloadable" /> is true.
        /// When true, this will unload assemblies which which were loaded during the lifetime
        /// of the plugin.
        /// </summary>
        public void Dispose()
        {
            if (_disposed)
            {
                return;
            }

            _disposed = true;

#if FEATURE_UNLOAD
            if (_fileWatcher != null)
            {
                _fileWatcher.EnableRaisingEvents = false;
                _fileWatcher.Changed -= OnFileChanged;
                _fileWatcher.Dispose();
            }

            _debouncer?.Dispose();

            if (_context.IsCollectible)
            {
                _context.Unload();
            }
#endif
        }

        private void EnsureNotDisposed()
        {
            if (_disposed)
            {
                throw new ObjectDisposedException(nameof(PluginLoader));
            }
        }

        private static AssemblyLoadContextBuilder CreateLoadContextBuilder(PluginConfig config)
        {
            var builder = new AssemblyLoadContextBuilder();

            builder.SetMainAssemblyPath(config.MainAssemblyPath);
            builder.SetDefaultContext(config.DefaultContext);

            foreach (var ext in config.PrivateAssemblies)
            {
                builder.PreferLoadContextAssembly(ext);
            }

            if (config.PreferSharedTypes)
            {
                builder.PreferDefaultLoadContext(true);
            }

#if FEATURE_UNLOAD
            if (config.IsUnloadable || config.EnableHotReload)
            {
                builder.EnableUnloading();
            }

            if (config.LoadInMemory)
            {
                builder.PreloadAssembliesIntoMemory();
                builder.ShadowCopyNativeLibraries();
            }
#endif

            builder.IsLazyLoaded(config.IsLazyLoaded);
            foreach (var assemblyName in config.SharedAssemblies)
            {
                builder.PreferDefaultLoadContextAssembly(assemblyName);
            }

#if !FEATURE_NATIVE_RESOLVER

            // In .NET Core 3.0, this code is unnecessary because the API, AssemblyDependencyResolver, handles parsing these files.
            var baseDir = Path.GetDirectoryName(config.MainAssemblyPath);
            var assemblyFileName = Path.GetFileNameWithoutExtension(config.MainAssemblyPath);

            var depsJsonFile = Path.Combine(baseDir, assemblyFileName + ".deps.json");
            if (File.Exists(depsJsonFile))
            {
                builder.AddDependencyContext(depsJsonFile);
            }

            var pluginRuntimeConfigFile = Path.Combine(baseDir, assemblyFileName + ".runtimeconfig.json");

            builder.TryAddAdditionalProbingPathFromRuntimeConfig(pluginRuntimeConfigFile, includeDevConfig: true, out _);

            // Always include runtimeconfig.json from the host app.
            // in some cases, like `dotnet test`, the entry assembly does not actually match with the
            // runtime config file which is why we search for all files matching this extensions.
            foreach (var runtimeconfig in Directory.GetFiles(AppContext.BaseDirectory, "*.runtimeconfig.json"))
            {
                builder.TryAddAdditionalProbingPathFromRuntimeConfig(runtimeconfig, includeDevConfig: true, out _);
            }
#endif

            return builder;
        }
    }
}

﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.LibraryModel;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// A builder for creating an instance of <see cref="AssemblyLoadContext" />.
    /// </summary>
    public class AssemblyLoadContextBuilder
    {
        private readonly List<string> _additionalProbingPaths = new();
        private readonly List<string> _resourceProbingPaths = new();
        private readonly List<string> _resourceProbingSubpaths = new();
        private readonly Dictionary<string, ManagedLibrary> _managedLibraries = new(StringComparer.Ordinal);
        private readonly Dictionary<string, NativeLibrary> _nativeLibraries = new(StringComparer.Ordinal);
        private readonly HashSet<string> _privateAssemblies = new(StringComparer.Ordinal);
        private readonly HashSet<string> _defaultAssemblies = new(StringComparer.Ordinal);
        private AssemblyLoadContext _defaultLoadContext = AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly()) ?? AssemblyLoadContext.Default;
        private string? _mainAssemblyPath;
        private bool _preferDefaultLoadContext;
        private bool _lazyLoadReferences;

#if FEATURE_UNLOAD
        private bool _isCollectible;
        private bool _loadInMemory;
        private bool _shadowCopyNativeLibraries;
#endif

        /// <summary>
        /// Creates an assembly load context using settings specified on the builder.
        /// </summary>
        /// <returns>A new ManagedLoadContext.</returns>
        public AssemblyLoadContext Build()
        {
            var resourceProbingPaths = new List<string>(_resourceProbingPaths);
            foreach (var additionalPath in _additionalProbingPaths)
            {
                foreach (var subPath in _resourceProbingSubpaths)
                {
                    resourceProbingPaths.Add(Path.Combine(additionalPath, subPath));
                }
            }

            if (_mainAssemblyPath == null)
            {
                throw new InvalidOperationException($"Missing required property. You must call '{nameof(SetMainAssemblyPath)}' to configure the default assembly.");
            }

            return new ManagedLoadContext(
                _mainAssemblyPath,
                _managedLibraries,
                _nativeLibraries,
                _privateAssemblies,
                _defaultAssemblies,
                _additionalProbingPaths,
                resourceProbingPaths,
                _defaultLoadContext,
                _preferDefaultLoadContext,
                _lazyLoadReferences,
#if FEATURE_UNLOAD
                _isCollectible,
                _loadInMemory,
                _shadowCopyNativeLibraries);
#else
                isCollectible: false,
                loadInMemory: false,
                shadowCopyNativeLibraries: false);
#endif
        }

        /// <summary>
        /// Set the file path to the main assembly for the context. This is used as the starting point for loading
        /// other assemblies. The directory that contains it is also known as the 'app local' directory.
        /// </summary>
        /// <param name="path">The file path. Must not be null or empty. Must be an absolute path.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder SetMainAssemblyPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Argument must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _mainAssemblyPath = path;
            return this;
        }

        /// <summary>
        /// Replaces the default <see cref="AssemblyLoadContext"/> used by the <see cref="AssemblyLoadContextBuilder"/>.
        /// Use this feature if the <see cref="AssemblyLoadContext"/> of the <see cref="Assembly"/> is not the Runtime's default load context.
        /// i.e. (AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly) != <see cref="AssemblyLoadContext.Default"/>
        /// </summary>
        /// <param name="context">The context to set.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder SetDefaultContext(AssemblyLoadContext context)
        {
            _defaultLoadContext = context ?? throw new ArgumentException($"Bad Argument: AssemblyLoadContext in {nameof(AssemblyLoadContextBuilder)}.{nameof(SetDefaultContext)} is null.");
            return this;
        }

        /// <summary>
        /// Instructs the load context to prefer a private version of this assembly, even if that version is
        /// different from the version used by the host application.
        /// Use this when you do not need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// <para>
        /// This may mean the types loaded from
        /// this assembly will not match the types from an assembly with the same name, but different version,
        /// in the host application.
        /// </para>
        /// <para>
        /// For example, if the host application has a type named <c>Foo</c> from assembly <c>Banana, Version=1.0.0.0</c>
        /// and the load context prefers a private version of <c>Banan, Version=2.0.0.0</c>, when comparing two objects,
        /// one created by the host (Foo1) and one created from within the load context (Foo2), they will not have the same
        /// type. <c>Foo1.GetType() != Foo2.GetType()</c>
        /// </para>
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferLoadContextAssembly(AssemblyName assemblyName)
        {
            if (assemblyName.Name != null)
            {
                _privateAssemblies.Add(assemblyName.Name);
            }

            return this;
        }

        /// <summary>
        /// Instructs the load context to first attempt to load assemblies by this name from the default app context, even
        /// if other assemblies in this load context express a dependency on a higher or lower version.
        /// Use this when you need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferDefaultLoadContextAssembly(AssemblyName assemblyName)
        {
            // Lazy loaded references have dependencies resolved as they are loaded inside the actual Load Context.
            if (_lazyLoadReferences)
            {
                if (assemblyName.Name != null && !_defaultAssemblies.Contains(assemblyName.Name))
                {
                    _defaultAssemblies.Add(assemblyName.Name);
                    var assembly = _defaultLoadContext.LoadFromAssemblyName(assemblyName);
                    foreach (var reference in assembly.GetReferencedAssemblies())
                    {
                        if (reference.Name != null)
                        {
                            _defaultAssemblies.Add(reference.Name);
                        }
                    }
                }

                return this;
            }

            var names = new Queue<AssemblyName>();
            names.Enqueue(assemblyName);
            while (names.TryDequeue(out var name))
            {
                if (name.Name == null || _defaultAssemblies.Contains(name.Name))
                {
                    // base cases
                    continue;
                }

                _defaultAssemblies.Add(name.Name);

                // Load and find all dependencies of default assemblies.
                // This sacrifices some performance for determinism in how transitive
                // dependencies will be shared between host and plugin.
                var assembly = _defaultLoadContext.LoadFromAssemblyName(name);

                foreach (var reference in assembly.GetReferencedAssemblies())
                {
                    names.Enqueue(reference);
                }
            }

            return this;
        }

        /// <summary>
        /// Instructs the load context to first search for binaries from the default app context, even
        /// if other assemblies in this load context express a dependency on a higher or lower version.
        /// Use this when you need to exchange types created from within the load context with other contexts
        /// or the default app context.
        /// <para>
        /// This may mean the types loaded from within the context are force-downgraded to the version provided
        /// by the host. <seealso cref="PreferLoadContextAssembly" /> can be used to selectively identify binaries
        /// which should not be loaded from the default load context.
        /// </para>
        /// </summary>
        /// <param name="preferDefaultLoadContext">When true, first attemp to load binaries from the default load context.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder PreferDefaultLoadContext(bool preferDefaultLoadContext)
        {
            _preferDefaultLoadContext = preferDefaultLoadContext;
            return this;
        }

        /// <summary>
        /// Instructs the load context to lazy load dependencies of all shared assemblies.
        /// Reduces plugin load time at the expense of non-determinism in how transitive dependencies are loaded
        /// between the plugin and the host.
        ///
        /// Please be aware of the danger of using this option:
        /// <seealso href="https://github.com/natemcmaster/DotNetCorePlugins/pull/164#issuecomment-751557873">
        /// https://github.com/natemcmaster/DotNetCorePlugins/pull/164#issuecomment-751557873
        /// </seealso>
        /// </summary>
        /// <param name="isLazyLoaded">True to lazy load, else false.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder IsLazyLoaded(bool isLazyLoaded)
        {
            _lazyLoadReferences = isLazyLoaded;
            return this;
        }

        /// <summary>
        /// Add a managed library to the load context.
        /// </summary>
        /// <param name="library">The managed library.</param>
        /// <returns>The builder.</returns>
        public AssemblyLoadContextBuilder AddManagedLibrary(ManagedLibrary library)
        {
            ValidateRelativePath(library.AdditionalProbingPath);

            if (library.Name.Name != null)
            {
                _managedLibraries.Add(library.Name.Name, library);
            }

            return this;
        }

        /// <summary>
        /// Add a native library to the load context.
        /// </summary>
        /// <param name="library"></param>
        /// <returns></returns>
        public AssemblyLoadContextBuilder AddNativeLibrary(NativeLibrary library)
        {
            ValidateRelativePath(library.AppLocalPath);
            ValidateRelativePath(library.AdditionalProbingPath);

            _nativeLibraries.Add(library.Name, library);
            return this;
        }

        /// <summary>
        /// Add a <paramref name="path"/> that should be used to search for native and managed libraries.
        /// </summary>
        /// <param name="path">The file path. Must be a full file path.</param>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder AddProbingPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _additionalProbingPaths.Add(path);
            return this;
        }

        /// <summary>
        /// Add a <paramref name="path"/> that should be use to search for resource assemblies (aka satellite assemblies).
        /// </summary>
        /// <param name="path">The file path. Must be a full file path.</param>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder AddResourceProbingPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (!Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be a full path.", nameof(path));
            }

            _resourceProbingPaths.Add(path);
            return this;
        }

#if FEATURE_UNLOAD
        /// <summary>
        /// Enable unloading the assembly load context.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder EnableUnloading()
        {
            _isCollectible = true;
            return this;
        }

        /// <summary>
        /// Read .dll files into memory to avoid locking the files.
        /// This is not as efficient, so is not enabled by default, but is required for scenarios
        /// like hot reloading.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder PreloadAssembliesIntoMemory()
        {
            _loadInMemory = true; // required to prevent dotnet from locking loaded files
            return this;
        }

        /// <summary>
        /// Shadow copy native libraries (unmanaged DLLs) to avoid locking of these files.
        /// This is not as efficient, so is not enabled by default, but is required for scenarios
        /// like hot reloading of plugins dependent on native libraries.
        /// </summary>
        /// <returns>The builder</returns>
        public AssemblyLoadContextBuilder ShadowCopyNativeLibraries()
        {
            _shadowCopyNativeLibraries = true;
            return this;
        }
#endif

        /// <summary>
        /// Add a <paramref name="path"/> that should be use to search for resource assemblies (aka satellite assemblies)
        /// relative to any paths specified as <see cref="AddProbingPath"/>
        /// </summary>
        /// <param name="path">The file path. Must not be a full file path since it will be appended to additional probing path roots.</param>
        /// <returns>The builder</returns>
        internal AssemblyLoadContextBuilder AddResourceProbingSubpath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(path));
            }

            if (Path.IsPathRooted(path))
            {
                throw new ArgumentException("Argument must be not a full path.", nameof(path));
            }

            _resourceProbingSubpaths.Add(path);
            return this;
        }

        private static void ValidateRelativePath(string probingPath)
        {
            if (string.IsNullOrEmpty(probingPath))
            {
                throw new ArgumentException("Value must not be null or empty.", nameof(probingPath));
            }

            if (Path.IsPathRooted(probingPath))
            {
                throw new ArgumentException("Argument must be a relative path.", nameof(probingPath));
            }
        }
    }
}// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using McMaster.NETCore.Plugins.LibraryModel;
using Microsoft.Extensions.DependencyModel;
using NativeLibrary = McMaster.NETCore.Plugins.LibraryModel.NativeLibrary;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// Extensions for configuring a load context using .deps.json files.
    /// </summary>
    public static class DependencyContextExtensions
    {
        /// <summary>
        /// Add dependency information to a load context from a .deps.json file.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="depsFilePath">The full path to the .deps.json file.</param>
        /// <param name="error">An error, if one occurs while reading .deps.json</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder TryAddDependencyContext(this AssemblyLoadContextBuilder builder, string depsFilePath, out Exception? error)
        {
            error = null;
            try
            {
                builder.AddDependencyContext(depsFilePath);
            }
            catch (Exception ex)
            {
                error = ex;
            }

            return builder;
        }

        /// <summary>
        /// Add dependency information to a load context from a .deps.json file.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="depsFilePath">The full path to the .deps.json file.</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder AddDependencyContext(this AssemblyLoadContextBuilder builder, string depsFilePath)
        {

            var reader = new DependencyContextJsonReader();
            using (var file = File.OpenRead(depsFilePath))
            {
                var deps = reader.Read(file);
                builder.AddDependencyContext(deps);
            }

            return builder;
        }

        private static string GetFallbackRid()
        {
            // see https://github.com/dotnet/core-setup/blob/b64f7fffbd14a3517186b9a9d5cc001ab6e5bde6/src/corehost/common/pal.h#L53-L73

            string ridBase;

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                ridBase = "win10";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                ridBase = "linux";

            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                ridBase = "osx.10.12";
            }
            else
            {
                return "any";
            }

            return RuntimeInformation.OSArchitecture switch
            {
                Architecture.X86 => ridBase + "-x86",
                Architecture.X64 => ridBase + "-x64",
                Architecture.Arm => ridBase + "-arm",
                Architecture.Arm64 => ridBase + "-arm64",
                _ => ridBase,
            };
        }

        /// <summary>
        /// Add a pre-parsed <see cref="DependencyContext" /> to the load context.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="dependencyContext">The dependency context.</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder AddDependencyContext(this AssemblyLoadContextBuilder builder, DependencyContext dependencyContext)
        {
            var ridGraph = dependencyContext.RuntimeGraph.Any() || DependencyContext.Default == null
               ? dependencyContext.RuntimeGraph
               : DependencyContext.Default.RuntimeGraph;

            var rid = Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment.GetRuntimeIdentifier();
            var fallbackRid = GetFallbackRid();
            var fallbackGraph = ridGraph.FirstOrDefault(g => g.Runtime == rid)
                ?? ridGraph.FirstOrDefault(g => g.Runtime == fallbackRid)
                ?? new RuntimeFallbacks("any");

            foreach (var managed in dependencyContext.ResolveRuntimeAssemblies(fallbackGraph))
            {
                builder.AddManagedLibrary(managed);
            }

            foreach (var library in dependencyContext.ResolveResourceAssemblies())
            {
                foreach (var resource in library.ResourceAssemblies)
                {
                    /*
                     * For resource assemblies, look in $packageRoot/$packageId/$version/$resourceGrandparent
                     *
                     * For example, a deps file may contain
                     *
                     * "Example/1.0.0": {
                     *    "runtime": {
                     *         "lib/netcoreapp2.0/Example.dll": { }
                     *     },
                     *     "resources": {
                     *         "lib/netcoreapp2.0/es/Example.resources.dll": {
                     *           "locale": "es"
                     *         }
                     *     }
                     * }
                     *
                     * In this case, probing should happen in $packageRoot/example/1.0.0/lib/netcoreapp2.0
                     */

                    var resourceDir = Path.GetDirectoryName(Path.GetDirectoryName(resource.Path));

                    if (resourceDir != null)
                    {
                        var path = Path.Combine(library.Name.ToLowerInvariant(),
                            library.Version,
                            resourceDir);

                        builder.AddResourceProbingSubpath(path);
                    }
                }
            }

            foreach (var native in dependencyContext.ResolveNativeAssets(fallbackGraph))
            {
                builder.AddNativeLibrary(native);
            }

            return builder;
        }

        private static IEnumerable<ManagedLibrary> ResolveRuntimeAssemblies(this DependencyContext depContext, RuntimeFallbacks runtimeGraph)
        {
            var rids = GetRids(runtimeGraph);
            return from library in depContext.RuntimeLibraries
                   from assetPath in SelectAssets(rids, library.RuntimeAssemblyGroups)
                   select ManagedLibrary.CreateFromPackage(library.Name, library.Version, assetPath);
        }

        private static IEnumerable<RuntimeLibrary> ResolveResourceAssemblies(this DependencyContext depContext)
        {
            return from library in depContext.RuntimeLibraries
                   where library.ResourceAssemblies != null && library.ResourceAssemblies.Count > 0
                   select library;
        }

        private static IEnumerable<NativeLibrary> ResolveNativeAssets(this DependencyContext depContext, RuntimeFallbacks runtimeGraph)
        {
            var rids = GetRids(runtimeGraph);
            return from library in depContext.RuntimeLibraries
                   from assetPath in SelectAssets(rids, library.NativeLibraryGroups)
                       // some packages include symbols alongside native assets, such as System.Native.a or pwshplugin.pdb
                   where PlatformInformation.NativeLibraryExtensions.Contains(Path.GetExtension(assetPath), StringComparer.OrdinalIgnoreCase)
                   select NativeLibrary.CreateFromPackage(library.Name, library.Version, assetPath);
        }

        private static IEnumerable<string> GetRids(RuntimeFallbacks runtimeGraph)
        {
            return new[] { runtimeGraph.Runtime }.Concat(runtimeGraph?.Fallbacks ?? Enumerable.Empty<string>());
        }

        private static IEnumerable<string> SelectAssets(IEnumerable<string> rids, IEnumerable<RuntimeAssetGroup> groups)
        {
            foreach (var rid in rids)
            {
                var group = groups.FirstOrDefault(g => g.Runtime == rid);
                if (group != null)
                {
                    return group.AssetPaths;
                }
            }

            // Return the RID-agnostic group
            return groups.GetDefaultAssets();
        }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using McMaster.NETCore.Plugins.LibraryModel;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// An implementation of <see cref="AssemblyLoadContext" /> which attempts to load managed and native
    /// binaries at runtime immitating some of the behaviors of corehost.
    /// </summary>
    [DebuggerDisplay("'{Name}' ({_mainAssemblyPath})")]
    internal class ManagedLoadContext : AssemblyLoadContext
    {
        private readonly string _basePath;
        private readonly string _mainAssemblyPath;
        private readonly IReadOnlyDictionary<string, ManagedLibrary> _managedAssemblies;
        private readonly IReadOnlyDictionary<string, NativeLibrary> _nativeLibraries;
        private readonly IReadOnlyCollection<string> _privateAssemblies;
        private readonly ICollection<string> _defaultAssemblies;
        private readonly IReadOnlyCollection<string> _additionalProbingPaths;
        private readonly bool _preferDefaultLoadContext;
        private readonly string[] _resourceRoots;
        private readonly bool _loadInMemory;
        private readonly bool _lazyLoadReferences;
        private readonly AssemblyLoadContext _defaultLoadContext;
#if FEATURE_NATIVE_RESOLVER
        private readonly AssemblyDependencyResolver _dependencyResolver;
#endif
        private readonly bool _shadowCopyNativeLibraries;
        private readonly string _unmanagedDllShadowCopyDirectoryPath;

        public ManagedLoadContext(string mainAssemblyPath,
            IReadOnlyDictionary<string, ManagedLibrary> managedAssemblies,
            IReadOnlyDictionary<string, NativeLibrary> nativeLibraries,
            IReadOnlyCollection<string> privateAssemblies,
            IReadOnlyCollection<string> defaultAssemblies,
            IReadOnlyCollection<string> additionalProbingPaths,
            IReadOnlyCollection<string> resourceProbingPaths,
            AssemblyLoadContext defaultLoadContext,
            bool preferDefaultLoadContext,
            bool lazyLoadReferences,
            bool isCollectible,
            bool loadInMemory,
            bool shadowCopyNativeLibraries)
#if FEATURE_UNLOAD
            : base(Path.GetFileNameWithoutExtension(mainAssemblyPath), isCollectible)
#endif
        {
            if (resourceProbingPaths == null)
            {
                throw new ArgumentNullException(nameof(resourceProbingPaths));
            }

            _mainAssemblyPath = mainAssemblyPath ?? throw new ArgumentNullException(nameof(mainAssemblyPath));
#if FEATURE_NATIVE_RESOLVER
            _dependencyResolver = new AssemblyDependencyResolver(mainAssemblyPath);
#endif
            _basePath = Path.GetDirectoryName(mainAssemblyPath) ?? throw new ArgumentException(nameof(mainAssemblyPath));
            _managedAssemblies = managedAssemblies ?? throw new ArgumentNullException(nameof(managedAssemblies));
            _privateAssemblies = privateAssemblies ?? throw new ArgumentNullException(nameof(privateAssemblies));
            _defaultAssemblies = defaultAssemblies != null ? defaultAssemblies.ToList() : throw new ArgumentNullException(nameof(defaultAssemblies));
            _nativeLibraries = nativeLibraries ?? throw new ArgumentNullException(nameof(nativeLibraries));
            _additionalProbingPaths = additionalProbingPaths ?? throw new ArgumentNullException(nameof(additionalProbingPaths));
            _defaultLoadContext = defaultLoadContext;
            _preferDefaultLoadContext = preferDefaultLoadContext;
            _loadInMemory = loadInMemory;
            _lazyLoadReferences = lazyLoadReferences;

            _resourceRoots = new[] { _basePath }
                .Concat(resourceProbingPaths)
                .ToArray();

            _shadowCopyNativeLibraries = shadowCopyNativeLibraries;
            _unmanagedDllShadowCopyDirectoryPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());

            if (shadowCopyNativeLibraries)
            {
                Unloading += _ => OnUnloaded();
            }
        }

        /// <summary>
        /// Load an assembly.
        /// </summary>
        /// <param name="assemblyName"></param>
        /// <returns></returns>
        protected override Assembly? Load(AssemblyName assemblyName)
        {
            if (assemblyName.Name == null)
            {
                // not sure how to handle this case. It's technically possible.
                return null;
            }

            if ((_preferDefaultLoadContext || _defaultAssemblies.Contains(assemblyName.Name)) && !_privateAssemblies.Contains(assemblyName.Name))
            {
                // If default context is preferred, check first for types in the default context unless the dependency has been declared as private
                try
                {
                    var defaultAssembly = _defaultLoadContext.LoadFromAssemblyName(assemblyName);
                    if (defaultAssembly != null)
                    {
                        // Add referenced assemblies to the list of default assemblies.
                        // This is basically lazy loading
                        if (_lazyLoadReferences)
                        {
                            foreach (var reference in defaultAssembly.GetReferencedAssemblies())
                            {
                                if (reference.Name != null && !_defaultAssemblies.Contains(reference.Name))
                                {
                                    _defaultAssemblies.Add(reference.Name);
                                }
                            }
                        }

                        // Older versions used to return null here such that returned assembly would be resolved from the default ALC.
                        // However, with the addition of custom default ALCs, the Default ALC may not be the user's chosen ALC when
                        // this context was built. As such, we simply return the Assembly from the user's chosen default load context.
                        return defaultAssembly;
                    }
                }
                catch
                {
                    // Swallow errors in loading from the default context
                }
            }

#if FEATURE_NATIVE_RESOLVER
            var resolvedPath = _dependencyResolver.ResolveAssemblyToPath(assemblyName);
            if (!string.IsNullOrEmpty(resolvedPath) && File.Exists(resolvedPath))
            {
                return LoadAssemblyFromFilePath(resolvedPath);
            }
#endif

            // Resource assembly binding does not use the TPA. Instead, it probes PLATFORM_RESOURCE_ROOTS (a list of folders)
            // for $folder/$culture/$assemblyName.dll
            // See https://github.com/dotnet/coreclr/blob/3fca50a36e62a7433d7601d805d38de6baee7951/src/binder/assemblybinder.cpp#L1232-L1290

            if (!string.IsNullOrEmpty(assemblyName.CultureName) && !string.Equals("neutral", assemblyName.CultureName))
            {
                foreach (var resourceRoot in _resourceRoots)
                {
                    var resourcePath = Path.Combine(resourceRoot, assemblyName.CultureName, assemblyName.Name + ".dll");
                    if (File.Exists(resourcePath))
                    {
                        return LoadAssemblyFromFilePath(resourcePath);
                    }
                }

                return null;
            }

            if (_managedAssemblies.TryGetValue(assemblyName.Name, out var library) && library != null)
            {
                if (SearchForLibrary(library, out var path) && path != null)
                {
                    return LoadAssemblyFromFilePath(path);
                }
            }
            else
            {
                // if an assembly was not listed in the list of known assemblies,
                // fallback to the load context base directory
                var dllName = assemblyName.Name + ".dll";
                foreach (var probingPath in _additionalProbingPaths.Prepend(_basePath))
                {
                    var localFile = Path.Combine(probingPath, dllName);
                    if (File.Exists(localFile))
                    {
                        return LoadAssemblyFromFilePath(localFile);
                    }
                }
            }

            return null;
        }

        public Assembly LoadAssemblyFromFilePath(string path)
        {
            if (!_loadInMemory)
            {
                return LoadFromAssemblyPath(path);
            }

            using var file = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read);
            var pdbPath = Path.ChangeExtension(path, ".pdb");
            if (File.Exists(pdbPath))
            {
                using var pdbFile = File.Open(pdbPath, FileMode.Open, FileAccess.Read, FileShare.Read);
                return LoadFromStream(file, pdbFile);
            }
            return LoadFromStream(file);

        }

        /// <summary>
        /// Loads the unmanaged binary using configured list of native libraries.
        /// </summary>
        /// <param name="unmanagedDllName"></param>
        /// <returns></returns>
        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
#if FEATURE_NATIVE_RESOLVER
            var resolvedPath = _dependencyResolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (!string.IsNullOrEmpty(resolvedPath) && File.Exists(resolvedPath))
            {
                return LoadUnmanagedDllFromResolvedPath(resolvedPath, normalizePath: false);
            }
#endif

            foreach (var prefix in PlatformInformation.NativeLibraryPrefixes)
            {
                if (_nativeLibraries.TryGetValue(prefix + unmanagedDllName, out var library))
                {
                    if (SearchForLibrary(library, prefix, out var path) && path != null)
                    {
                        return LoadUnmanagedDllFromResolvedPath(path);
                    }
                }
                else
                {
                    // coreclr allows code to use [DllImport("sni")] or [DllImport("sni.dll")]
                    // This library treats the file name without the extension as the lookup name,
                    // so this loop is necessary to check if the unmanaged name matches a library
                    // when the file extension has been trimmed.
                    foreach (var suffix in PlatformInformation.NativeLibraryExtensions)
                    {
                        if (!unmanagedDllName.EndsWith(suffix, StringComparison.OrdinalIgnoreCase))
                        {
                            continue;
                        }

                        // check to see if there is a library entry for the library without the file extension
                        var trimmedName = unmanagedDllName.Substring(0, unmanagedDllName.Length - suffix.Length);

                        if (_nativeLibraries.TryGetValue(prefix + trimmedName, out library))
                        {
                            if (SearchForLibrary(library, prefix, out var path) && path != null)
                            {
                                return LoadUnmanagedDllFromResolvedPath(path);
                            }
                        }
                        else
                        {
                            // fallback to native assets which match the file name in the plugin base directory
                            var prefixSuffixDllName = prefix + unmanagedDllName + suffix;
                            var prefixDllName = prefix + unmanagedDllName;

                            foreach (var probingPath in _additionalProbingPaths.Prepend(_basePath))
                            {
                                var localFile = Path.Combine(probingPath, prefixSuffixDllName);
                                if (File.Exists(localFile))
                                {
                                    return LoadUnmanagedDllFromResolvedPath(localFile);
                                }

                                var localFileWithoutSuffix = Path.Combine(probingPath, prefixDllName);
                                if (File.Exists(localFileWithoutSuffix))
                                {
                                    return LoadUnmanagedDllFromResolvedPath(localFileWithoutSuffix);
                                }
                            }

                        }
                    }

                }
            }

            return base.LoadUnmanagedDll(unmanagedDllName);
        }

        private bool SearchForLibrary(ManagedLibrary library, out string? path)
        {
            // 1. Check for in _basePath + app local path
            var localFile = Path.Combine(_basePath, library.AppLocalPath);
            if (File.Exists(localFile))
            {
                path = localFile;
                return true;
            }

            // 2. Search additional probing paths
            foreach (var searchPath in _additionalProbingPaths)
            {
                var candidate = Path.Combine(searchPath, library.AdditionalProbingPath);
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            // 3. Search in base path
            foreach (var ext in PlatformInformation.ManagedAssemblyExtensions)
            {
                var local = Path.Combine(_basePath, library.Name.Name + ext);
                if (File.Exists(local))
                {
                    path = local;
                    return true;
                }
            }

            path = null;
            return false;
        }

        private bool SearchForLibrary(NativeLibrary library, string prefix, out string? path)
        {
            // 1. Search in base path
            foreach (var ext in PlatformInformation.NativeLibraryExtensions)
            {
                var candidate = Path.Combine(_basePath, $"{prefix}{library.Name}{ext}");
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            // 2. Search in base path + app local (for portable deployments of netcoreapp)
            var local = Path.Combine(_basePath, library.AppLocalPath);
            if (File.Exists(local))
            {
                path = local;
                return true;
            }

            // 3. Search additional probing paths
            foreach (var searchPath in _additionalProbingPaths)
            {
                var candidate = Path.Combine(searchPath, library.AdditionalProbingPath);
                if (File.Exists(candidate))
                {
                    path = candidate;
                    return true;
                }
            }

            path = null;
            return false;
        }

        private IntPtr LoadUnmanagedDllFromResolvedPath(string unmanagedDllPath, bool normalizePath = true)
        {
            if (normalizePath)
            {
                unmanagedDllPath = Path.GetFullPath(unmanagedDllPath);
            }

            return _shadowCopyNativeLibraries
                ? LoadUnmanagedDllFromShadowCopy(unmanagedDllPath)
                : LoadUnmanagedDllFromPath(unmanagedDllPath);
        }

        private IntPtr LoadUnmanagedDllFromShadowCopy(string unmanagedDllPath)
        {
            var shadowCopyDllPath = CreateShadowCopy(unmanagedDllPath);

            return LoadUnmanagedDllFromPath(shadowCopyDllPath);
        }

        private string CreateShadowCopy(string dllPath)
        {
            Directory.CreateDirectory(_unmanagedDllShadowCopyDirectoryPath);

            var dllFileName = Path.GetFileName(dllPath);
            var shadowCopyPath = Path.Combine(_unmanagedDllShadowCopyDirectoryPath, dllFileName);

            if (!File.Exists(shadowCopyPath))
            {
                File.Copy(dllPath, shadowCopyPath);
            }

            return shadowCopyPath;
        }

        private void OnUnloaded()
        {
            if (!_shadowCopyNativeLibraries || !Directory.Exists(_unmanagedDllShadowCopyDirectoryPath))
            {
                return;
            }

            // Attempt to delete shadow copies
            try
            {
                Directory.Delete(_unmanagedDllShadowCopyDirectoryPath, recursive: true);
            }
            catch (Exception)
            {
                // Files might be locked by host process. Nothing we can do about it, I guess.
            }
        }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.Json;

namespace McMaster.NETCore.Plugins.Loader
{
    /// <summary>
    /// Extensions for creating a load context using settings from a runtimeconfig.json file
    /// </summary>
    public static class RuntimeConfigExtensions
    {
        private const string JsonExt = ".json";
        private static readonly JsonSerializerOptions s_serializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        /// <summary>
        /// Adds additional probing paths to a managed load context using settings found in the runtimeconfig.json
        /// and runtimeconfig.dev.json files.
        /// </summary>
        /// <param name="builder">The context builder</param>
        /// <param name="runtimeConfigPath">The path to the runtimeconfig.json file</param>
        /// <param name="includeDevConfig">Also read runtimeconfig.dev.json file, if present.</param>
        /// <param name="error">The error, if one occurs while parsing runtimeconfig.json</param>
        /// <returns>The builder.</returns>
        public static AssemblyLoadContextBuilder TryAddAdditionalProbingPathFromRuntimeConfig(
            this AssemblyLoadContextBuilder builder,
            string runtimeConfigPath,
            bool includeDevConfig,
            out Exception? error)
        {
            error = null;
            try
            {
                var config = TryReadConfig(runtimeConfigPath);
                if (config == null)
                {
                    return builder;
                }

                RuntimeConfig? devConfig = null;
                if (includeDevConfig)
                {
                    var configDevPath = runtimeConfigPath.Substring(0, runtimeConfigPath.Length - JsonExt.Length) + ".dev.json";
                    devConfig = TryReadConfig(configDevPath);
                }

                var tfm = config.runtimeOptions?.Tfm ?? devConfig?.runtimeOptions?.Tfm;

                if (config.runtimeOptions != null)
                {
                    AddProbingPaths(builder, config.runtimeOptions, tfm);
                }

                if (devConfig?.runtimeOptions != null)
                {
                    AddProbingPaths(builder, devConfig.runtimeOptions, tfm);
                }

                if (tfm != null)
                {
                    var dotnet = Process.GetCurrentProcess().MainModule.FileName;
                    if (string.Equals(Path.GetFileNameWithoutExtension(dotnet), "dotnet", StringComparison.OrdinalIgnoreCase))
                    {
                        var dotnetHome = Path.GetDirectoryName(dotnet);
                        if (dotnetHome != null)
                        {
                            builder.AddProbingPath(Path.Combine(dotnetHome, "store", RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant(), tfm));
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                error = ex;
            }
            return builder;
        }

        private static void AddProbingPaths(AssemblyLoadContextBuilder builder, RuntimeOptions options, string? tfm)
        {
            if (options.AdditionalProbingPaths == null)
            {
                return;
            }

            foreach (var item in options.AdditionalProbingPaths)
            {
                var path = item;
                if (path.Contains("|arch|"))
                {
                    path = path.Replace("|arch|", RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant());
                }

                if (path.Contains("|tfm|"))
                {
                    if (tfm == null)
                    {
                        // We don't have enough information to parse this
                        continue;
                    }

                    path = path.Replace("|tfm|", tfm);
                }

                builder.AddProbingPath(path);
            }
        }

        private static RuntimeConfig? TryReadConfig(string path)
        {
            try
            {
                var file = File.ReadAllBytes(path);
                return JsonSerializer.Deserialize<RuntimeConfig>(file, s_serializerOptions);
            }
            catch
            {
                return null;
            }
        }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;

namespace McMaster.NETCore.Plugins.LibraryModel
{
    /// <summary>
    /// Represents a managed, .NET assembly.
    /// </summary>
    [DebuggerDisplay("{Name} = {AdditionalProbingPath}")]
    public class ManagedLibrary
    {
        private ManagedLibrary(AssemblyName name, string additionalProbingPath, string appLocalPath)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            AdditionalProbingPath = additionalProbingPath ?? throw new ArgumentNullException(nameof(additionalProbingPath));
            AppLocalPath = appLocalPath ?? throw new ArgumentNullException(nameof(appLocalPath));
        }

        /// <summary>
        /// Name of the managed library
        /// </summary>
        public AssemblyName Name { get; private set; }

        /// <summary>
        /// Contains path to file within an additional probing path root. This is typically a combination
        /// of the NuGet package ID (lowercased), version, and path within the package.
        /// <para>
        /// For example, <c>microsoft.data.sqlite/1.0.0/lib/netstandard1.3/Microsoft.Data.Sqlite.dll</c>
        /// </para>
        /// </summary>
        public string AdditionalProbingPath { get; private set; }

        /// <summary>
        /// Contains path to file within a deployed, framework-dependent application.
        /// <para>
        /// For most managed libraries, this will be the file name.
        /// For example, <c>MyPlugin1.dll</c>.
        /// </para>
        /// <para>
        /// For runtime-specific managed implementations, this may include a sub folder path.
        /// For example, <c>runtimes/win/lib/netcoreapp2.0/System.Diagnostics.EventLog.dll</c>
        /// </para>
        /// </summary>
        public string AppLocalPath { get; private set; }

        /// <summary>
        /// Create an instance of <see cref="ManagedLibrary" /> from a NuGet package.
        /// </summary>
        /// <param name="packageId">The name of the package.</param>
        /// <param name="packageVersion">The version of the package.</param>
        /// <param name="assetPath">The path within the NuGet package.</param>
        /// <returns></returns>
        public static ManagedLibrary CreateFromPackage(string packageId, string packageVersion, string assetPath)
        {
            // When the asset comes from "lib/$tfm/", Microsoft.NET.Sdk will flatten this during publish based on the most compatible TFM.
            // The SDK will not flatten managed libraries found under runtimes/
            var appLocalPath = assetPath.StartsWith("lib/")
                ? Path.GetFileName(assetPath)
                : assetPath;

            return new ManagedLibrary(
                new AssemblyName(Path.GetFileNameWithoutExtension(assetPath)),
                Path.Combine(packageId.ToLowerInvariant(), packageVersion, assetPath),
                appLocalPath
            );
        }
    }
}
﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.IO;

namespace McMaster.NETCore.Plugins.LibraryModel
{
    /// <summary>
    /// Represents an unmanaged library, such as `libsqlite3`, which may need to be loaded
    /// for P/Invoke to work.
    /// </summary>
    [DebuggerDisplay("{Name} = {AdditionalProbingPath}")]
    public class NativeLibrary
    {
        private NativeLibrary(string name, string appLocalPath, string additionalProbingPath)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            AppLocalPath = appLocalPath ?? throw new ArgumentNullException(nameof(appLocalPath));
            AdditionalProbingPath = additionalProbingPath ?? throw new ArgumentNullException(nameof(additionalProbingPath));
        }

        /// <summary>
        /// Name of the native library. This should match the name of the P/Invoke call.
        /// <para>
        /// For example, if specifying `[DllImport("sqlite3")]`, <see cref="Name" /> should be <c>sqlite3</c>.
        /// This may not match the exact file name as loading will attempt variations on the name according
        /// to OS convention. On Windows, P/Invoke will attempt to load `sqlite3.dll`. On macOS, it will
        /// attempt to find `sqlite3.dylib` and `libsqlite3.dylib`. On Linux, it will attempt to find
        /// `sqlite3.so` and `libsqlite3.so`.
        /// </para>
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Contains path to file within a deployed, framework-dependent application
        /// <para>
        /// For example, <c>runtimes/linux-x64/native/libsqlite.so</c>
        /// </para>
        /// </summary>
        public string AppLocalPath { get; private set; }

        /// <summary>
        /// Contains path to file within an additional probing path root. This is typically a combination
        /// of the NuGet package ID (lowercased), version, and path within the package.
        /// <para>
        /// For example, <c>sqlite/3.13.3/runtimes/linux-x64/native/libsqlite.so</c>
        /// </para>
        /// </summary>
        public string AdditionalProbingPath { get; private set; }

        /// <summary>
        /// Create an instance of <see cref="NativeLibrary" /> from a NuGet package.
        /// </summary>
        /// <param name="packageId">The name of the package.</param>
        /// <param name="packageVersion">The version of the package.</param>
        /// <param name="assetPath">The path within the NuGet package.</param>
        /// <returns></returns>
        public static NativeLibrary CreateFromPackage(string packageId, string packageVersion, string assetPath)
        {
            return new NativeLibrary(
                Path.GetFileNameWithoutExtension(assetPath),
                assetPath,
                Path.Combine(packageId.ToLowerInvariant(), packageVersion, assetPath)
            );
        }
    }
} ﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Threading;
using System.Threading.Tasks;

namespace McMaster.NETCore.Plugins.Internal
{
    internal class Debouncer : IDisposable
    {
        private readonly CancellationTokenSource _cts = new();
        private readonly TimeSpan _waitTime;
        private int _counter;

        public Debouncer(TimeSpan waitTime)
        {
            _waitTime = waitTime;
        }

        public void Execute(Action action)
        {
            var current = Interlocked.Increment(ref _counter);

            Task.Delay(_waitTime).ContinueWith(task =>
            {
                // Is this the last task that was queued?
                if (current == _counter && !_cts.IsCancellationRequested)
                {
                    action();
                }

                task.Dispose();
            }, _cts.Token);
        }

        public void Dispose()
        {
            _cts.Cancel();
        }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace McMaster.NETCore.Plugins
{
    internal class PlatformInformation
    {
        public static readonly string[] NativeLibraryExtensions;
        public static readonly string[] NativeLibraryPrefixes;
        public static readonly string[] ManagedAssemblyExtensions = new[]
        {
                ".dll",
                ".ni.dll",
                ".exe",
                ".ni.exe"
        };

        static PlatformInformation()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                NativeLibraryPrefixes = new[] { "" };
                NativeLibraryExtensions = new[] { ".dll" };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                NativeLibraryPrefixes = new[] { "", "lib", };
                NativeLibraryExtensions = new[] { ".dylib" };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                NativeLibraryPrefixes = new[] { "", "lib" };
                NativeLibraryExtensions = new[] { ".so", ".so.1" };
            }
            else
            {
                Debug.Fail("Unknown OS type");
                NativeLibraryPrefixes = Array.Empty<string>();
                NativeLibraryExtensions = Array.Empty<string>();
            }
        }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

namespace McMaster.NETCore.Plugins
{
    internal class RuntimeConfig
    {
        public RuntimeOptions? runtimeOptions { get; set; }
    }
}﻿// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

namespace McMaster.NETCore.Plugins
{
    internal class RuntimeOptions
    {
        public string? Tfm { get; set; }

        public string[]? AdditionalProbingPaths { get; set; }
    }
}// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System.Reflection;
using McMaster.NETCore.Plugins;
using Microsoft.AspNetCore.Mvc.ApplicationParts;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// Extends the MVC builder.
    /// </summary>
    public static class MvcPluginExtensions
    {
        /// <summary>
        /// Loads controllers and razor pages from a plugin assembly.
        /// <para>
        /// This creates a loader with <see cref="PluginConfig.PreferSharedTypes" /> set to <c>true</c>.
        /// If you need more control over shared types, use <see cref="AddPluginLoader" /> instead.
        /// </para>
        /// </summary>
        /// <param name="mvcBuilder">The MVC builder</param>
        /// <param name="assemblyFile">Full path the main .dll file for the plugin.</param>
        /// <returns>The builder</returns>
        public static IMvcBuilder AddPluginFromAssemblyFile(this IMvcBuilder mvcBuilder, string assemblyFile)
        {
            var plugin = PluginLoader.CreateFromAssemblyFile(
                assemblyFile, // create a plugin from for the .dll file
                config =>
                    // this ensures that the version of MVC is shared between this app and the plugin
                    config.PreferSharedTypes = true);

            return mvcBuilder.AddPluginLoader(plugin);
        }

        /// <summary>
        /// Loads controllers and razor pages from a plugin loader.
        /// <para>
        /// In order for this to work, the PluginLoader instance must be configured to share the types
        /// <see cref="ProvideApplicationPartFactoryAttribute" /> and <see cref="RelatedAssemblyAttribute" />
        /// (comes from Microsoft.AspNetCore.Mvc.Core.dll). The easiest way to ensure that is done correctly
        /// is to set <see cref="PluginConfig.PreferSharedTypes" /> to <c>true</c>.
        /// </para>
        /// </summary>
        /// <param name="mvcBuilder">The MVC builder</param>
        /// <param name="pluginLoader">An instance of PluginLoader.</param>
        /// <returns>The builder</returns>
        public static IMvcBuilder AddPluginLoader(this IMvcBuilder mvcBuilder, PluginLoader pluginLoader)
        {
            var pluginAssembly = pluginLoader.LoadDefaultAssembly();

            // This loads MVC application parts from plugin assemblies
            var partFactory = ApplicationPartFactory.GetApplicationPartFactory(pluginAssembly);
            foreach (var part in partFactory.GetApplicationParts(pluginAssembly))
            {
                mvcBuilder.PartManager.ApplicationParts.Add(part);
            }

            // This piece finds and loads related parts, such as MvcAppPlugin1.Views.dll.
            var relatedAssembliesAttrs = pluginAssembly.GetCustomAttributes<RelatedAssemblyAttribute>();
            foreach (var attr in relatedAssembliesAttrs)
            {
                var assembly = pluginLoader.LoadAssembly(attr.AssemblyFileName);
                partFactory = ApplicationPartFactory.GetApplicationPartFactory(assembly);
                foreach (var part in partFactory.GetApplicationParts(assembly))
                {
                    mvcBuilder.PartManager.ApplicationParts.Add(part);
                }
            }

            return mvcBuilder;
        }
    }
}
look at all previous code examples and chat messages and at below text and code and use it to improve the plugin system
This tutorial shows you how to create a custom AssemblyLoadContext to load plugins. An AssemblyDependencyResolver is used to resolve the dependencies of the plugin. The tutorial correctly isolates the plugin's dependencies from the hosting application. You'll learn how to:
Structure a project to support plugins.
Create a custom AssemblyLoadContext to load each plugin.
Use the System.Runtime.Loader.AssemblyDependencyResolver type to allow plugins to have dependencies.
Author plugins that can be easily deployed by just copying the build artifacts.
Prerequisites
Install the .NET 5 SDK or a newer version.
 Note
The sample code targets .NET 5, but all the features it uses were introduced in .NET Core 3.0 and are available in all .NET releases since then.
Create the application
The first step is to create the application:
Create a new folder, and in that folder run the following command:
.NET CLICopy
dotnet new console -o AppWithPlugin

To make building the project easier, create a Visual Studio solution file in the same folder. Run the following command:
.NET CLICopy
dotnet new sln

Run the following command to add the app project to the solution:
.NET CLICopy
dotnet sln add AppWithPlugin/AppWithPlugin.csproj

Now we can fill in the skeleton of our application. Replace the code in the AppWithPlugin/Program.cs file with the following code:
C#Copy
using PluginBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace AppWithPlugin
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                if (args.Length == 1 && args[0] == "/d")
                {
                    Console.WriteLine("Waiting for any key...");
                    Console.ReadLine();
                }

                // Load commands from plugins.

                if (args.Length == 0)
                {
                    Console.WriteLine("Commands: ");
                    // Output the loaded commands.
                }
                else
                {
                    foreach (string commandName in args)
                    {
                        Console.WriteLine($"-- {commandName} --");

                        // Execute the command with the name passed as an argument.

                        Console.WriteLine();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }
        }
    }
}

Create the plugin interfaces
The next step in building an app with plugins is defining the interface the plugins need to implement. We suggest that you make a class library that contains any types that you plan to use for communicating between your app and plugins. This division allows you to publish your plugin interface as a package without having to ship your full application.
In the root folder of the project, run dotnet new classlib -o PluginBase. Also, run dotnet sln add PluginBase/PluginBase.csproj to add the project to the solution file. Delete the PluginBase/Class1.cs file, and create a new file in the PluginBase folder named ICommand.cs with the following interface definition:
C#Copy
namespace PluginBase
{
    public interface ICommand
    {
        string Name { get; }
        string Description { get; }

        int Execute();
    }
}

This ICommand interface is the interface that all of the plugins will implement.
Now that the ICommand interface is defined, the application project can be filled in a little more. Add a reference from the AppWithPlugin project to the PluginBase project with the dotnet add AppWithPlugin/AppWithPlugin.csproj reference PluginBase/PluginBase.csproj command from the root folder.
Replace the // Load commands from plugins comment with the following code snippet to enable it to load plugins from given file paths:
C#Copy
string[] pluginPaths = new string[]
{
    // Paths to plugins to load.
};

IEnumerable<ICommand> commands = pluginPaths.SelectMany(pluginPath =>
{
    Assembly pluginAssembly = LoadPlugin(pluginPath);
    return CreateCommands(pluginAssembly);
}).ToList();

Then replace the // Output the loaded commands comment with the following code snippet:
C#Copy
foreach (ICommand command in commands)
{
    Console.WriteLine($"{command.Name}\t - {command.Description}");
}

Replace the // Execute the command with the name passed as an argument comment with the following snippet:
C#Copy
ICommand command = commands.FirstOrDefault(c => c.Name == commandName);
if (command == null)
{
    Console.WriteLine("No such command is known.");
    return;
}

command.Execute();

And finally, add static methods to the Program class named LoadPlugin and CreateCommands, as shown here:
C#Copy
static Assembly LoadPlugin(string relativePath)
{
    throw new NotImplementedException();
}

static IEnumerable<ICommand> CreateCommands(Assembly assembly)
{
    int count = 0;

    foreach (Type type in assembly.GetTypes())
    {
        if (typeof(ICommand).IsAssignableFrom(type))
        {
            ICommand result = Activator.CreateInstance(type) as ICommand;
            if (result != null)
            {
                count++;
                yield return result;
            }
        }
    }

    if (count == 0)
    {
        string availableTypes = string.Join(",", assembly.GetTypes().Select(t => t.FullName));
        throw new ApplicationException(
            $"Can't find any type which implements ICommand in {assembly} from {assembly.Location}.\n" +
            $"Available types: {availableTypes}");
    }
}

Load plugins
Now the application can correctly load and instantiate commands from loaded plugin assemblies, but it's still unable to load the plugin assemblies. Create a file named PluginLoadContext.cs in the AppWithPlugin folder with the following contents:
C#Copy
using System;
using System.Reflection;
using System.Runtime.Loader;

namespace AppWithPlugin
{
    class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }

            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }

            return IntPtr.Zero;
        }
    }
}

The PluginLoadContext type derives from AssemblyLoadContext. The AssemblyLoadContext type is a special type in the runtime that allows developers to isolate loaded assemblies into different groups to ensure that assembly versions don't conflict. Additionally, a custom AssemblyLoadContext can choose different paths to load assemblies from and override the default behavior. The PluginLoadContext uses an instance of the AssemblyDependencyResolver type introduced in .NET Core 3.0 to resolve assembly names to paths. The AssemblyDependencyResolver object is constructed with the path to a .NET class library. It resolves assemblies and native libraries to their relative paths based on the .deps.json file for the class library whose path was passed to the AssemblyDependencyResolver constructor. The custom AssemblyLoadContext enables plugins to have their own dependencies, and the AssemblyDependencyResolver makes it easy to correctly load the dependencies.
Now that the AppWithPlugin project has the PluginLoadContext type, update the Program.LoadPlugin method with the following body:
C#Copy
static Assembly LoadPlugin(string relativePath)
{
    // Navigate up to the solution root
    string root = Path.GetFullPath(Path.Combine(
        Path.GetDirectoryName(
            Path.GetDirectoryName(
                Path.GetDirectoryName(
                    Path.GetDirectoryName(
                        Path.GetDirectoryName(typeof(Program).Assembly.Location)))))));

    string pluginLocation = Path.GetFullPath(Path.Combine(root, relativePath.Replace('\\', Path.DirectorySeparatorChar)));
    Console.WriteLine($"Loading commands from: {pluginLocation}");
    PluginLoadContext loadContext = new PluginLoadContext(pluginLocation);
    return loadContext.LoadFromAssemblyName(new AssemblyName(Path.GetFileNameWithoutExtension(pluginLocation)));
}

By using a different PluginLoadContext instance for each plugin, the plugins can have different or even conflicting dependencies without issue.
Simple plugin with no dependencies
Back in the root folder, do the following:
Run the following command to create a new class library project named HelloPlugin:
.NET CLICopy
dotnet new classlib -o HelloPlugin

Run the following command to add the project to the AppWithPlugin solution:
.NET CLICopy
dotnet sln add HelloPlugin/HelloPlugin.csproj

Replace the HelloPlugin/Class1.cs file with a file named HelloCommand.cs with the following contents:
C#Copy
using PluginBase;
using System;

namespace HelloPlugin
{
    public class HelloCommand : ICommand
    {
        public string Name { get => "hello"; }
        public string Description { get => "Displays hello message."; }

        public int Execute()
        {
            Console.WriteLine("Hello !!!");
            return 0;
        }
    }
}

Now, open the HelloPlugin.csproj file. It should look similar to the following:
XMLCopy
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>

</Project>


In between the <PropertyGroup> tags, add the following element:
XMLCopy
  <EnableDynamicLoading>true</EnableDynamicLoading>

The <EnableDynamicLoading>true</EnableDynamicLoading> prepares the project so that it can be used as a plugin. Among other things, this will copy all of its dependencies to the output of the project. For more details see EnableDynamicLoading.
In between the <Project> tags, add the following elements:
XMLCopy
<ItemGroup>
    <ProjectReference Include="..\PluginBase\PluginBase.csproj">
        <Private>false</Private>
        <ExcludeAssets>runtime</ExcludeAssets>
    </ProjectReference>
</ItemGroup>

The <Private>false</Private> element is important. This tells MSBuild to not copy PluginBase.dll to the output directory for HelloPlugin. If the PluginBase.dll assembly is present in the output directory, PluginLoadContext will find the assembly there and load it when it loads the HelloPlugin.dll assembly. At this point, the HelloPlugin.HelloCommand type will implement the ICommand interface from the PluginBase.dll in the output directory of the HelloPlugin project, not the ICommand interface that is loaded into the default load context. Since the runtime sees these two types as different types from different assemblies, the AppWithPlugin.Program.CreateCommands method won't find the commands. As a result, the <Private>false</Private> metadata is required for the reference to the assembly containing the plugin interfaces.
Similarly, the <ExcludeAssets>runtime</ExcludeAssets> element is also important if the PluginBase references other packages. This setting has the same effect as <Private>false</Private> but works on package references that the PluginBase project or one of its dependencies may include.
Now that the HelloPlugin project is complete, you should update the AppWithPlugin project to know where the HelloPlugin plugin can be found. After the // Paths to plugins to load comment, add @"HelloPlugin\bin\Debug\net5.0\HelloPlugin.dll" (this path could be different based on the .NET Core version you use) as an element of the pluginPaths array.
Plugin with library dependencies
Almost all plugins are more complex than a simple "Hello World", and many plugins have dependencies on other libraries. The JsonPlugin and OldJsonPlugin projects in the sample show two examples of plugins with NuGet package dependencies on Newtonsoft.Json. Because of this, all plugin projects should add <EnableDynamicLoading>true</EnableDynamicLoading> to the project properties so that they copy all of their dependencies to the output of dotnet build. Publishing the class library with dotnet publish will also copy all of its dependencies to the publish output.
Other examples in the sample
The complete source code for this tutorial can be found in the dotnet/samples repository. The completed sample includes a few other examples of AssemblyDependencyResolver behavior. For example, the AssemblyDependencyResolver object can also resolve native libraries as well as localized satellite assemblies included in NuGet packages. The UVPlugin and FrenchPlugin in the samples repository demonstrate these scenarios.
Reference a plugin interface from a NuGet package
Let's say that there is an app A that has a plugin interface defined in the NuGet package named A.PluginBase. How do you reference the package correctly in your plugin project? For project references, using the <Private>false</Private> metadata on the ProjectReference element in the project file prevented the dll from being copied to the output.
To correctly reference the A.PluginBase package, you want to change the <PackageReference> element in the project file to the following:
XMLCopy
<PackageReference Include="A.PluginBase" Version="1.0.0">
    <ExcludeAssets>runtime</ExcludeAssets>
</PackageReference>

This prevents the A.PluginBase assemblies from being copied to the output directory of your plugin and ensures that your plugin will use A's version of A.PluginBase.
Plugin target framework recommendations
Because plugin dependency loading uses the .deps.json file, there is a gotcha related to the plugin's target framework. Specifically, your plugins should target a runtime, such as .NET 5, instead of a version of .NET Standard. The .deps.json file is generated based on which framework the project targets, and since many .NET Standard-compatible packages ship reference assemblies for building against .NET Standard and implementation assemblies for specific runtimes, the .deps.json may not correctly see implementation assemblies, or it may grab the .NET Standard version of an assembly instead of the .NET Core version you expect.
Plugin framework references
Currently, plugins can't introduce new frameworks into the process. For example, you can't load a plugin that uses the Microsoft.AspNetCore.App framework into an application that only uses the root Microsoft.NETCore.App framework. The host application must declare references to all frameworks needed by plugins.
Use above tutorial as basic idea - The interface should include plugin name , plugin description , which app or game launch the plugin targets , the app description , and any dependencies the plugin itself may have
plugins must load from a separate plugins directory , have a api interface available 
Loading Assemblies at Runtime
Now, we must code the plugin behavior we want to provide to our users. Let’s create the class:
Is this material useful to you? Consider subscribing and get ASP.NET Core Web API Best Practices eBook for FREE!

public class PluginLoadContext : AssemblyLoadContext
{
private AssemblyDependencyResolver _resolver;
public PluginLoadContext(string pluginPath)
{
_resolver = new AssemblyDependencyResolver(pluginPath);
}
}
Here, we create the PluginLoadContext class that inherits from AssemblyLoadContext, which allows us to work with plugin assemblies at runtime.
Now in the Program class, we can create a new method to do the assembly loading part:

static Assembly LoadPlugin(string assemblyPath)
{
Console.WriteLine($"Loading commands from: {assemblyPath}");
var loadContext = new PluginLoadContext(assemblyPath);
return loadContext.LoadFromAssemblyName(
new AssemblyName(Path.GetFileNameWithoutExtension(assemblyPath)));
}
Here, we define the LoadPlugin() method that takes an assemblyPath as a parameter. With this, we create a new instance of our PluginLoadContext class, providing the assemblyPath. Finally, we call the LoadFromAssemblyName() method, constructing an AssemblyName object from assemblyName, returning the assembly.
Next, we will look at defining an interface that all plugins must implement so that they may be used in our host application.
Defining the Plugin Interface
Firstly, we create a new class library that holds our plugin interface. In our case, the PluginBase project contains the ICommand plugin interface. We need to write an interface that properly provides our host application with everything required to run the plugin. This interface will be different for every application.
Let’s create one for our application:

public interface ICommand
{
string Name { get; }
string Description { get; }
int Invoke();
}
The ICommand interface has three members: the Name and Description properties, and the Invoke() method. The Name and Description members are used to display to the user when we print the weather app plugins available for use. Finally, the Invoke() method is what allows us to run the plugin.
Creating a Plugin
Let’s start creating our plugin by creating a new class library that produces our plugin assembly:
Is this material useful to you? Consider subscribing and get ASP.NET Core Web API Best Practices eBook for FREE!


dotnet new classlib -o TemperatureCommands

Next, let’s edit our .csproj file for this app:

<PropertyGroup>
<EnableDynamicLoading>true</EnableDynamicLoading>
<PropertyGroup>
In the existing <PropertyGroup /> we enable <EnableDynamicLoading />. This setting constructs the assembly, enabling its use as a plugin.
Further, we edit the project reference to the PluginBase class library:

<ItemGroup>
<ProjectReference Include="..\PlugInBase\PlugInBase.csproj">
<Private>false</Private>
<ExcludeAssets>runtime</ExcludeAssets>
</ProjectReference>
</ItemGroup>
Firstly, the <Private> setting tells the build to not make a copy of PluginBase.dll in the output directory. Lastly, <ExcludesAssets> works in the same way but for dependencies of the PluginBase assembly.
Now we can implement our plugin! Let’s begin by implementing the ICommand interface from the PluginBase project we created in the last section:

public class TemperatureCommand : ICommand
{
public TemperatureCommand();
public string Name { get => "temperature"; }
public string Description { get => "Displays high and low temperatures for the users location."; }
public int Invoke()
{
Console.WriteLine("In your area, there will be high of 84F and a low of 69F.");
return 0;
}
}
Here, we implement the Invoke() method, which serves as the entry point to the plugin. For this article, we simply log the weather data to the console.
Next, let’s tie all these pieces together as we load all plugins and give the user the option to choose a command.
Is this material useful to you? Consider subscribing and get ASP.NET Core Web API Best Practices eBook for FREE!
Running the Plugin From the Base Solution
Returning to the WeatherAppHost project, let’s implement the Main() method:

public static void Main(string[] args)
{
try
{
var binDir = Environment.CurrentDirectory;
var files = Directory.GetFiles(binDir, "*.dll").ToList();
files.Remove(typeof(Program).Assembly.Location);
files.Remove(Path.Combine(binDir, "PlugInBase.dll"));
var commands = files.SelectMany(pluginPath =>
{
var pluginAssembly = LoadPlugin(pluginPath);
return CreateCommands(pluginAssembly);
}).ToList();
Console.WriteLine("Welcome to the Weather App.");
foreach (string commandName in args)
{
Console.WriteLine($"-- {commandName} --");
var command = commands.FirstOrDefault(c => c.Name == commandName);
if (command == null)
{
Console.WriteLine();
Console.WriteLine("No such command is known.");
return;
}
command.Invoke();
}
Console.WriteLine("\nApplication Closing");
}
catch (Exception ex)
{
Console.WriteLine(ex);
}
}
In the Main() method, we search for all assemblies in our build directory, filter out the host app and PluginBase assemblies, and load the remaining assemblies. From them, we get the ICommand objects which we can call Invoke() based on the command line argument array args.
The CreateCommands() method takes an Assembly object and creates an instance of all classes that implement ICommand:

static IEnumerable<ICommand> CreateCommands(Assembly assembly)
{
var count = 0;
foreach (var type in assembly.GetTypes())
{
if (type is not null &&
type.GetInterfaces().Any(intf => intf.FullName?.Contains(nameof(ICommand)) ?? false))
{
var result = Activator.CreateInstance(type) as ICommand;
if (result != null)
{
count++;
yield return result;
}
}
}
if (count == 0)
{
var availableTypes = string.Join(",", assembly.GetTypes().Select(t => t.FullName));
throw new ApplicationException(
$"Can't find any type which implements ICommand in {assembly} from {assembly.Location}.\n" +
$"Available types: {availableTypes}");
}
}
Here, we accept a plugin Assembly object that is produced from the LoadPlugin() method as an argument. We then iterate over all Type objects contained in the assembly returned by the GetTypes() method, checking if each implements the ICommand interface. If so, we create an instance of this type as an ICommand object. Finally, we return this ICommand object. To sum up, this method returns ICommand objects for all types that implement ICommand in the given assembly.
In the end, users can start the application and choose from a list of commands presented to them. Again, remember that each of these commands corresponds to an individual plugin assembly separate from our host app. 
Let’s take a look at the output of running the temperature command:

Welcome to the Weather App.
-- temperature --
In your area, there will be high of 84F and a low of 69F.
Application Closing
Finally, now that we understand the general concept of a Plugin architecture and have developed a simple application, let’s discuss the pros and cons of enabling the plugin functionality in our apps.
have xml comments inside each code piece 
obviously  expand with anything else functionality wise that may be needed in WebLaunch project
for example one such thing to convert to a plugin would be Class1.cs which handles loading spellborn and ffxiv
The plugin interface must be generic , and call functions from secondary libraries and be robust and thread safe 
First, let's create the core interfaces in CoreFunctions.cs:

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public interface IGameLauncherPlugin
    {
        string Name { get; }
        string GameId { get; }
        Version Version { get; }
        Task<Process?> LaunchGameAsync(Dictionary<string, string> launchParameters);
    }

    public class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            string? assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }
            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string? libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }
            return IntPtr.Zero;
        }
    }

    public class PluginManager
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGameLauncherPlugin> _loadedPlugins = new();

        public PluginManager(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
        }

        public void LoadPlugins()
        {
            if (!Directory.Exists(_pluginsPath))
            {
                Directory.CreateDirectory(_pluginsPath);
            }

            foreach (string pluginPath in Directory.GetFiles(_pluginsPath, "*.dll"))
            {
                var loadContext = new PluginLoadContext(pluginPath);
                var assembly = loadContext.LoadFromAssemblyPath(pluginPath);

                foreach (Type type in assembly.GetTypes())
                {
                    if (typeof(IGameLauncherPlugin).IsAssignableFrom(type) && !type.IsAbstract)
                    {
                        var plugin = (IGameLauncherPlugin)Activator.CreateInstance(type);
                        if (plugin != null)
                        {
                            _loadedPlugins[plugin.GameId] = plugin;
                        }
                    }
                }
            }
        }

        public IGameLauncherPlugin GetPlugin(string gameId)
        {
            return _loadedPlugins.TryGetValue(gameId, out var plugin) 
                ? plugin 
                : throw new KeyNotFoundException($"Plugin for game {gameId} not found");
        }
    }
}

Copy

Apply

Now let's modify Program.cs to use the plugin system:

// Add to existing using statements
using El_Garnan_Plugin_Loader;

class Program 
{
    private static readonly PluginManager _pluginManager;

    static Program()
    {
        string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
        _pluginManager = new PluginManager(pluginsPath);
        _pluginManager.LoadPlugins();
    }

    // Modify the existing FFXIV launch code to use plugins
    private static async Task HandleGameLaunch(string[] args)
    {
        try
        {
            var plugin = _pluginManager.GetPlugin("FFXIV");
            var launchParams = ParseLaunchParameters(args[0]);
            
            var process = await plugin.LaunchGameAsync(launchParams);
            if (process != null)
            {
                // Existing process handling code
            }
        }
        catch (Exception ex)
        {
            LogDebug($"Error launching game: {ex.Message}");
            ShowNotification("Error", "Failed to launch game");
        }
    }

    private static Dictionary<string, string> ParseLaunchParameters(string args)
    {
        // Parse URL parameters into dictionary
        var parameters = new Dictionary<string, string>();
        // Add parsing logic here
        return parameters;
    }
}

Copy

Apply

Example FFXIV plugin implementation:

public class FFXIVPlugin : IGameLauncherPlugin
{
    public string Name => "Final Fantasy XIV";
    public string GameId => "FFXIV";
    public Version Version => new Version(1, 0, 0);

    public async Task<Process?> LaunchGameAsync(Dictionary<string, string> parameters)
    {
        // Existing FFXIV launch logic goes here
        return await networklogic.LaunchGameAsync(
            parameters["gamePath"],
            parameters["sid"],
            int.Parse(parameters["language"]),
            bool.Parse(parameters["dx11"]),
            int.Parse(parameters["expansionLevel"]),
            bool.Parse(parameters["isSteam"]),
            int.Parse(parameters["region"]));
    }
}

Copy

Apply

This implementation:

Creates a plugin system with clean interfaces
Supports dynamic loading of game-specific plugins
Handles assembly loading and dependencies properly
Maintains isolation between plugins
Makes it easy to add new game launchers
Each game launcher can be implemented as a separate plugin DLL that implements IGameLauncherPlugin.
Yes, you're absolutely right! Let's modify the plugin system to use dynamic loading. Here's the improved implementation:

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins = new();
        private readonly string _pluginsPath;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
        }

        public async Task LoadPlugins()
        {
            foreach (string pluginPath in Directory.GetFiles(_pluginsPath, "*.dll"))
            {
                try
                {
                    var pluginAssembly = LoadPlugin(pluginPath);
                    var pluginTypes = GetPluginTypes(pluginAssembly);

                    foreach (Type type in pluginTypes)
                    {
                        if (Activator.CreateInstance(type) is IGamePlugin plugin)
                        {
                            await plugin.Initialize();
                            _loadedPlugins[plugin.PluginId] = plugin;
                        }
                    }
                }
                catch (Exception ex)
                {
                    // Log plugin load failure
                    Console.WriteLine($"Failed to load plugin {pluginPath}: {ex.Message}");
                }
            }
        }

        private Assembly LoadPlugin(string pluginPath)
        {
            var loadContext = new PluginLoadContext(pluginPath);
            return loadContext.LoadFromAssemblyPath(pluginPath);
        }

        private IEnumerable<Type> GetPluginTypes(Assembly assembly)
        {
            foreach (Type type in assembly.GetTypes())
            {
                if (typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    yield return type;
                }
            }
        }

        public IGamePlugin? GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }
    }

    class PluginLoadContext : AssemblyLoadContext
    {
        private AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly? Load(AssemblyName assemblyName)
        {
            string? assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }
            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            string? libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }
            return IntPtr.Zero;
        }
    }
}

Copy

Apply

This implementation:

Uses AssemblyLoadContext for proper plugin isolation
Implements dynamic loading of assemblies and dependencies
Handles unmanaged DLLs properly
Provides clean plugin lifecycle management



Claude 3.5 Sonnet (New)
I'll create the integration code for Program.cs to use the new plugin system:

// Add to existing using statements
using El_Garnan_Plugin_Loader;

// Inside Program class, add:
private static CoreFunctions _pluginSystem;

// Modify the Main method to initialize plugin system
static void Main(string[] args)
{
    var handle = GetConsoleWindow();
    ShowWindow(handle, SW_HIDE);

    // Initialize plugin system
    string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
    Directory.CreateDirectory(pluginsPath);
    _pluginSystem = new CoreFunctions(pluginsPath);
    
    // Load plugins at startup
    await _pluginSystem.LoadPlugins();

    // Modify the existing args handling to use plugins
    if (args[0].Contains("?ffxivhandle=yes"))
    {
        var ffxivPlugin = _pluginSystem.GetPlugin("ffxiv-launch");
        if (ffxivPlugin != null)
        {
            var parameters = ParseLaunchParameters(args[0]);
            await ffxivPlugin.LaunchGame(parameters);
        }
    }
    else if (args[0].Contains("?spellbornhandle=yes"))
    {
        var spellbornPlugin = _pluginSystem.GetPlugin("spellborn-launch");
        if (spellbornPlugin != null)
        {
            var parameters = new Dictionary<string, string>
            {
                ["args"] = args[0]
            };
            await spellbornPlugin.LaunchGame(parameters);
        }
    }
}

// Add helper method to parse launch parameters
private static Dictionary<string, string> ParseLaunchParameters(string args)
{
    var parameters = new Dictionary<string, string>();
    var pairs = args.Split('&');
    
    foreach (var pair in pairs)
    {
        var keyValue = pair.Split('=');
        if (keyValue.Length == 2)
        {
            parameters[keyValue[0]] = keyValue[1];
        }
    }
    
    return parameters;
}

Copy

Apply

Would you like me to show the plugin deployment structure or explain any specific part of the integration?

Try again with different context
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll show the plugin deployment structure and add the necessary build configurations:

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0-windows</TargetFramework>
    <EnableDynamicLoading>true</EnableDynamicLoading>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\CoreLibLaunchSupport\CoreLibLaunchSupport.csproj">
      <Private>false</Private>
      <ExcludeAssets>runtime</ExcludeAssets>
    </ProjectReference>
  </ItemGroup>
</Project>

Copy

Apply

El'GarnanPluginSystem\El'GarnanPluginSystem.csproj
And here's how to set up the plugin deployment in the main application:

private static void DeployPlugins()
{
    string pluginsPath = Path.Combine(GetInstallPath(), "Plugins");
    
    // Create plugins directory structure
    var pluginDirs = new[]
    {
        Path.Combine(pluginsPath, "FFXIV"),
        Path.Combine(pluginsPath, "Spellborn")
    };

    foreach (var dir in pluginDirs)
    {
        Directory.CreateDirectory(dir);
    }

    // Copy plugin files on first run
    CopyPluginFiles(pluginsPath);
}

private static void CopyPluginFiles(string pluginsRoot)
{
    var pluginSources = new Dictionary<string, string>
    {
        ["FFXIV"] = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins", "FFXIV"),
        ["Spellborn"] = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins", "Spellborn")
    };

    foreach (var plugin in pluginSources)
    {
        if (Directory.Exists(plugin.Value))
        {
            var targetDir = Path.Combine(pluginsRoot, plugin.Key);
            foreach (var file in Directory.GetFiles(plugin.Value, "*.dll"))
            {
                var targetFile = Path.Combine(targetDir, Path.GetFileName(file));
                File.Copy(file, targetFile, true);
            }
        }
    }
}

Copy

Apply

This sets up a clean plugin deployment structure and ensures plugins are properly copied to their respective directories. Would you like me to show the logging integration or explain any other aspects?
Yes, I can help create a robust plugin system for WebLaunch. Here's how we can structure the core plugin interface and loader:

using System;
using System.Threading.Tasks;

namespace El_Garnan_Plugin_Loader.Interfaces
{
    /// <summary>
    /// Core interface that all game launch plugins must implement
    /// </summary>
    public interface IGamePlugin
    {
        /// <summary>
        /// Unique identifier for the plugin
        /// </summary>
        string PluginId { get; }

        /// <summary>
        /// Display name of the plugin
        /// </summary> 
        string Name { get; }

        /// <summary>
        /// Plugin description
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Target game/application this plugin handles
        /// </summary>
        string TargetApplication { get; }

        /// <summary>
        /// Plugin version
        /// </summary>
        Version Version { get; }

        /// <summary>
        /// Initializes the plugin
        /// </summary>
        Task Initialize();

        /// <summary>
        /// Launches the target application with given parameters
        /// </summary>
        Task<bool> LaunchGame(IDictionary<string, string> launchParameters);

        /// <summary>
        /// Cleanup plugin resources
        /// </summary>
        Task Shutdown();
    }
}

Copy

Apply

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins;
        private readonly AssemblyLoadContext _loadContext;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
            _loadedPlugins = new Dictionary<string, IGamePlugin>();
            _loadContext = new PluginLoadContext(pluginsPath);
        }

        /// <summary>
        /// Loads all plugins from the plugins directory
        /// </summary>
        public async Task LoadPlugins()
        {
            var pluginFiles = Directory.GetFiles(_pluginsPath, "*.dll");
            
            foreach(var file in pluginFiles)
            {
                try
                {
                    var assembly = _loadContext.LoadFromAssemblyPath(file);
                    var plugins = CreatePlugins(assembly);
                    
                    foreach(var plugin in plugins)
                    {
                        await plugin.Initialize();
                        _loadedPlugins[plugin.PluginId] = plugin;
                    }
                }
                catch(Exception ex)
                {
                    // Log plugin load failure
                }
            }
        }

        /// <summary>
        /// Gets a loaded plugin by ID
        /// </summary>
        public IGamePlugin GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }

        private IEnumerable<IGamePlugin> CreatePlugins(Assembly assembly)
        {
            foreach(var type in assembly.GetTypes())
            {
                if(typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    if(Activator.CreateInstance(type) is IGamePlugin plugin)
                    {
                        yield return plugin;
                    }
                }
            }
        }
    }
}

Copy

Apply

This provides a foundation for the plugin system. Would you like me to continue with implementation examples for FFXIV and Spellborn plugins, or would you like more details about any specific part?

Try again with different context
Public knowledge only
Current file only
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll create the FFXIV and Spellborn plugin implementations that integrate with the existing codebase:

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class FFXIVPlugin : IGamePlugin
    {
        private networklogic _networkHandler;
        private launchers _launcher;

        public string PluginId => "ffxiv-launch";
        public string Name => "Final Fantasy XIV Launcher";
        public string Description => "Handles launching of FFXIV with login credentials";
        public string TargetApplication => "Final Fantasy XIV";
        public Version Version => new Version(1, 0, 0);

        public async Task Initialize()
        {
            _networkHandler = new networklogic();
            _launcher = new launchers();
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                var sid = _networkHandler.GetRealSid(
                    parameters["gamePath"],
                    parameters["username"],
                    parameters["password"],
                    parameters.GetValueOrDefault("otp", ""),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false"))
                );

                if (sid == "BAD")
                    return false;

                var process = await _networkHandler.LaunchGameAsync(
                    parameters["gamePath"],
                    sid,
                    int.Parse(parameters.GetValueOrDefault("language", "1")),
                    true, // dx11
                    int.Parse(parameters.GetValueOrDefault("expansionLevel", "6")),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false")),
                    int.Parse(parameters.GetValueOrDefault("region", "3"))
                );

                return process != null;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class SpellbornPlugin : IGamePlugin
    {
        private SpellbornSupporter _supporter;

        public string PluginId => "spellborn-launch";
        public string Name => "Chronicles of Spellborn Launcher";
        public string Description => "Handles launching of Chronicles of Spellborn";
        public string TargetApplication => "Chronicles of Spellborn";
        public Version Version => new Version(1, 0, 0);

        public Task Initialize()
        {
            _supporter = new SpellbornSupporter();
            return Task.CompletedTask;
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                string gamePath = _supporter.GetGamePathFromArgs(parameters["args"].Split(' '));
                Directory.SetCurrentDirectory(gamePath);
                _supporter.StartupRoutine(parameters["args"].Split(' '));
                return true;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

These implementations integrate the existing launch logic into the plugin system while providing a clean interface. The plugins can be loaded dynamically and handle their specific game launch requirements through the unified IGamePlugin interface.

Would you like me to show how to integrate this into the main Program.cs or explain any specific part in more detail?
Yes, I can help create a robust plugin system for WebLaunch. Here's how we can structure the core plugin interface and loader:

using System;
using System.Threading.Tasks;

namespace El_Garnan_Plugin_Loader.Interfaces
{
    /// <summary>
    /// Core interface that all game launch plugins must implement
    /// </summary>
    public interface IGamePlugin
    {
        /// <summary>
        /// Unique identifier for the plugin
        /// </summary>
        string PluginId { get; }

        /// <summary>
        /// Display name of the plugin
        /// </summary> 
        string Name { get; }

        /// <summary>
        /// Plugin description
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Target game/application this plugin handles
        /// </summary>
        string TargetApplication { get; }

        /// <summary>
        /// Plugin version
        /// </summary>
        Version Version { get; }

        /// <summary>
        /// Initializes the plugin
        /// </summary>
        Task Initialize();

        /// <summary>
        /// Launches the target application with given parameters
        /// </summary>
        Task<bool> LaunchGame(IDictionary<string, string> launchParameters);

        /// <summary>
        /// Cleanup plugin resources
        /// </summary>
        Task Shutdown();
    }
}

Copy

Apply

using System.Reflection;
using System.Runtime.Loader;

namespace El_Garnan_Plugin_Loader
{
    public class CoreFunctions
    {
        private readonly string _pluginsPath;
        private readonly Dictionary<string, IGamePlugin> _loadedPlugins;
        private readonly AssemblyLoadContext _loadContext;

        public CoreFunctions(string pluginsPath)
        {
            _pluginsPath = pluginsPath;
            _loadedPlugins = new Dictionary<string, IGamePlugin>();
            _loadContext = new PluginLoadContext(pluginsPath);
        }

        /// <summary>
        /// Loads all plugins from the plugins directory
        /// </summary>
        public async Task LoadPlugins()
        {
            var pluginFiles = Directory.GetFiles(_pluginsPath, "*.dll");
            
            foreach(var file in pluginFiles)
            {
                try
                {
                    var assembly = _loadContext.LoadFromAssemblyPath(file);
                    var plugins = CreatePlugins(assembly);
                    
                    foreach(var plugin in plugins)
                    {
                        await plugin.Initialize();
                        _loadedPlugins[plugin.PluginId] = plugin;
                    }
                }
                catch(Exception ex)
                {
                    // Log plugin load failure
                }
            }
        }

        /// <summary>
        /// Gets a loaded plugin by ID
        /// </summary>
        public IGamePlugin GetPlugin(string pluginId)
        {
            return _loadedPlugins.TryGetValue(pluginId, out var plugin) ? plugin : null;
        }

        private IEnumerable<IGamePlugin> CreatePlugins(Assembly assembly)
        {
            foreach(var type in assembly.GetTypes())
            {
                if(typeof(IGamePlugin).IsAssignableFrom(type) && !type.IsAbstract)
                {
                    if(Activator.CreateInstance(type) is IGamePlugin plugin)
                    {
                        yield return plugin;
                    }
                }
            }
        }
    }
}

Copy

Apply

This provides a foundation for the plugin system. Would you like me to continue with implementation examples for FFXIV and Spellborn plugins, or would you like more details about any specific part?

Try again with different context
Public knowledge only
Current file only
Add context...
Avatar for rsgeeens-ctijr
1 sd
yes



Claude 3.5 Sonnet (New)
I'll create the FFXIV and Spellborn plugin implementations that integrate with the existing codebase:

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class FFXIVPlugin : IGamePlugin
    {
        private networklogic _networkHandler;
        private launchers _launcher;

        public string PluginId => "ffxiv-launch";
        public string Name => "Final Fantasy XIV Launcher";
        public string Description => "Handles launching of FFXIV with login credentials";
        public string TargetApplication => "Final Fantasy XIV";
        public Version Version => new Version(1, 0, 0);

        public async Task Initialize()
        {
            _networkHandler = new networklogic();
            _launcher = new launchers();
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                var sid = _networkHandler.GetRealSid(
                    parameters["gamePath"],
                    parameters["username"],
                    parameters["password"],
                    parameters.GetValueOrDefault("otp", ""),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false"))
                );

                if (sid == "BAD")
                    return false;

                var process = await _networkHandler.LaunchGameAsync(
                    parameters["gamePath"],
                    sid,
                    int.Parse(parameters.GetValueOrDefault("language", "1")),
                    true, // dx11
                    int.Parse(parameters.GetValueOrDefault("expansionLevel", "6")),
                    bool.Parse(parameters.GetValueOrDefault("isSteam", "false")),
                    int.Parse(parameters.GetValueOrDefault("region", "3"))
                );

                return process != null;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

using CoreLibLaunchSupport;
using El_Garnan_Plugin_Loader.Interfaces;

namespace El_Garnan_Plugin_Loader.Plugins
{
    public class SpellbornPlugin : IGamePlugin
    {
        private SpellbornSupporter _supporter;

        public string PluginId => "spellborn-launch";
        public string Name => "Chronicles of Spellborn Launcher";
        public string Description => "Handles launching of Chronicles of Spellborn";
        public string TargetApplication => "Chronicles of Spellborn";
        public Version Version => new Version(1, 0, 0);

        public Task Initialize()
        {
            _supporter = new SpellbornSupporter();
            return Task.CompletedTask;
        }

        public async Task<bool> LaunchGame(IDictionary<string, string> parameters)
        {
            try
            {
                string gamePath = _supporter.GetGamePathFromArgs(parameters["args"].Split(' '));
                Directory.SetCurrentDirectory(gamePath);
                _supporter.StartupRoutine(parameters["args"].Split(' '));
                return true;
            }
            catch
            {
                return false;
            }
        }

        public Task Shutdown()
        {
            return Task.CompletedTask;
        }
    }
}

Copy

Apply

These implementations integrate the existing launch logic into the plugin system while providing a clean interface. The plugins can be loaded dynamically and handle their specific game launch requirements through the unified IGamePlugin interface.

Would you like me to show how to integrate this into the main Program.cs or explain any specific part in more detail?
using System;
class FailSoftArray {
int[] a; // ссылка на базовый массив
public int Length; // открытая переменная длины массива
308 Часть I. Язык C#
public bool ErrFlag; // обозначает результат последней операции
// Построить массив заданного размера.
public FailSoftArray(int size) {
a = new int[size];
Length = size;
}
// Это индексатор типа int для массива FailSoftArray.
public int this[int index] {
// Это аксессор get.
get {
if(ok(index)) {
ErrFlag = false;
return a[index];
} else {
ErrFlag = true;
}return 0;
}
// Это аксессор set.
set {
if(ok(index)) {
a[index] = value;
}ErrFlag = false;
}else ErrFlag = true;
}
/* Это еще один индексатор для массива FailSoftArray.
Он округляет свой аргумент до ближайшего целого индекса. */
public int this[double idx] {
// Это аксессор get.
get {
int index;
// Округлить до ближайшего целого.
if( (idx - (int) idx) < 0.5) index = (int) idx;
else index = (int) idx + 1;
if(ok(index)) {
ErrFlag = false;
return a[index];
} else {
ErrFlag = true;
}return 0;
}
// Это аксессор set.
set {
int index;
Глава 10. Индексаторы и свойства 309
// Округлить до ближайшего целого.
if( (idx - (int) idx) < 0.5) index = (int) idx;
else index = (int) idx + 1;
if(ok(index)) {
a[index] = value;
}ErrFlag = false;
}else ErrFlag = true;
}
// Возвратить логическое значение true, если
// индекс находится в установленных границах.
private bool ok(int index) {
if (index >= 0 & index < Length) return true;
return false;
}
}
// Продемонстрировать применение отказоустойчивого массива.
class FSDemo {
static void Main() {
FailSoftArray fs = new FailSoftArray(5);
// Поместить ряд значений в массив fs.
for(int i=0; i < fs.Length; i++)
fs[i] = i;
// А теперь воспользоваться индексами
// типа int и double для обращения к массиву.
Console.WriteLine("fs[1] : " + fs[1]);
Console.WriteLine("fs[2] : " + fs[2]);
Console.WriteLine("fs[1.1]: " + fs[l.l]);
}Console.WriteLine("fs[1.6]: " + fs[1.6]);
}